# 1. MySQL 索引的最左前缀匹配原则是什么？ 

最左前缀匹配原则指的是：在使用联合索引时，查询条件必须从索引的最左侧开始匹配。如果一个联合索引包含多个列，查询条件必须包含第一个列的条件，然后是第二个列，以此类推。

## 底层原理

联合索引在 B+ 树中的排列方式遵循“从左到右”的顺序。例如，联合索引 `(first_name, last_name, age)` 会按照 `(first_name, last_name, age)` 的顺序在 B+ 树中进行排序。

MySQL 在查找时会优先使用 `first_name` 作为匹配依据，然后依次使用 `last_name` 和 `age`。因此，组合索引能够从左到右依次高效匹配，**跳过最左侧字段会导致无法利用该索引**。
# 2. 数据库的脏读、不可重复读和幻读分别是什么？
## 1）脏读（Dirty Read）
一个事务读取到另一个事务未提交的数据。如果该未提交事务最终被回滚，那么第一个事务读取的数据就是不一致的（脏的）。
## 2）不可重复读（Non-repeatable Read）
在同一事务中，读取同一数据两次，但由于其他事务的提交，读取的结果不同。  
例如：事务 A 读取了一行数据，事务 B 修改并提交了这行数据，导致事务 A 再次读取时得到不同的值。
## 3）幻读（Phantom Read）
在同一事务中，执行相同的查询操作，返回的结果集由于其他事务的插入而发生变化。  
例如：事务 A 查询符合某条件的记录，事务 B 插入了新记录并提交，导致事务 A 再次查询时看到不同的记录数量。

## 几种读与隔离级别的关系

脏读、不可重复读和幻读是不同隔离级别下可能发生的问题，具体对应关系如下：

- 读未提交（Read Uncommitted）：允许脏读。
- 读已提交（Read Committed）：防止脏读，但可能出现不可重复读。
- 可重复读（Repeatable Read）：防止脏读和不可重复读，但仍可能出现幻读（注：MySQL 的 InnoDB 引擎在可重复读级别通过间隙锁机制，很大程度上避免了幻读）。
- 串行化（Serializable）：防止所有三种问题，但性能开销较大。

## 不可重复读与幻读的区别

- **幻读**：针对数据的**数量**。在事务期间，由于其他事务提交了新插入或删除的记录，导致同一查询操作返回的结果集总量发生变化（比如多了或少了记录）。
- **不可重复读**：针对数据的**内容**。在事务执行期间，同一条数据的字段值被其他已提交的事务修改，导致两次读取该数据时得到不同的内容。
# 3. MySQL 的存储引擎有哪些？它们之间有什么区别？ 
## InnoDB（MySQL 默认引擎）
1. **事务与并发控制**
   - 支持事务，实现四种标准隔离级别，默认使用可重复读级别
   - 利用 MVCC（多版本并发控制）支持高并发
   - 支持行级锁，通过行锁+间隙锁在可重复读级别下有效防止幻读
   - 支持崩溃后的数据安全恢复

2. **外键与约束**
   - 支持外键约束，但互联网项目通常避免使用（性能考虑）
   - 建议通过业务代码实现数据约束逻辑

3. **并发性能**
   - 采用行级锁定，在多用户同时读写场景下表现优异
   - 适合 OLTP（在线事务处理）场景

4. **索引结构**
   - 主键索引为聚簇索引（数据与索引存储在一起）
   - 辅助索引（非主键索引）仅存储索引值与主键
   - 当辅助索引无法覆盖查询列时，需通过主键回表查询完整数据
## MyISAM
1. **功能特性**
   - 基于 ISAM 引擎发展而来
   - 支持全文检索、数据压缩、空间函数
   - **不支持事务和行级锁**，仅提供表级锁
   - 适用于 OLAP（在线分析处理）场景，尤其是以读取操作为主的场景
2. **索引结构**
   - 同样使用 B+ 树索引
   - 数据与索引分开存储，主键索引与非主键索引结构差异不大
   - 叶子节点不存储完整数据，仅指向数据存储位置
两者最核心的区别在于事务支持、锁机制和索引存储方式，这也决定了它们适用于不同的业务场景。
# 4. 
