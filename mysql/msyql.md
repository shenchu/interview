# 目录

1. [MySQL 索引的最左前缀匹配原则是什么？](#1-mysql-索引的最左前缀匹配原则是什么)
2. [数据库的脏读、不可重复读和幻读分别是什么？](#2-数据库的脏读不可重复读和幻读分别是什么)
3. [MySQL 的存储引擎有哪些？它们之间有什么区别？](#3-mysql-的存储引擎有哪些它们之间有什么区别)
4. [MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？](#4-mysql-innodb-引擎中的聚簇索引和非聚簇索引有什么区别)
5. [MySQL 中的回表是什么](#5-mysql-中的回表是什么)
6. [为什么 MySQL 选择使用 B+ 树作为索引结构](#6-为什么-mysql-选择使用-b-树作为索引结构)
7. [详细描述一条 SQL 语句在 MySQL 中的执行过程](#7-详细描述一条-sql-语句在-mysql-中的执行过程)
8. [MySQL 中的 MVCC 是什么？](#8-mysql-中的-mvcc-是什么)
9. [MySQL 中有哪些锁类型](#9-mysql-中有哪些锁类型)

# 1. MySQL 索引的最左前缀匹配原则是什么？ 

最左前缀匹配原则指的是：在使用联合索引时，查询条件必须从索引的最左侧开始匹配。如果一个联合索引包含多个列，查询条件必须包含第一个列的条件，然后是第二个列，以此类推。

## 底层原理

联合索引在 B+ 树中的排列方式遵循“从左到右”的顺序。例如，联合索引 `(first_name, last_name, age)` 会按照 `(first_name, last_name, age)` 的顺序在 B+ 树中进行排序。

MySQL 在查找时会优先使用 `first_name` 作为匹配依据，然后依次使用 `last_name` 和 `age`。因此，组合索引能够从左到右依次高效匹配，**跳过最左侧字段会导致无法利用该索引**。
# 2. 数据库的脏读、不可重复读和幻读分别是什么？
## 1）脏读（Dirty Read）
一个事务读取到另一个事务未提交的数据。如果该未提交事务最终被回滚，那么第一个事务读取的数据就是不一致的（脏的）。
## 2）不可重复读（Non-repeatable Read）
在同一事务中，读取同一数据两次，但由于其他事务的提交，读取的结果不同。  
例如：事务 A 读取了一行数据，事务 B 修改并提交了这行数据，导致事务 A 再次读取时得到不同的值。
## 3）幻读（Phantom Read）
在同一事务中，执行相同的查询操作，返回的结果集由于其他事务的插入而发生变化。  
例如：事务 A 查询符合某条件的记录，事务 B 插入了新记录并提交，导致事务 A 再次查询时看到不同的记录数量。

## 几种读与隔离级别的关系

脏读、不可重复读和幻读是不同隔离级别下可能发生的问题，具体对应关系如下：

- 读未提交（Read Uncommitted）：允许脏读。
- 读已提交（Read Committed）：防止脏读，但可能出现不可重复读。
- 可重复读（Repeatable Read）：防止脏读和不可重复读，但仍可能出现幻读（注：MySQL 的 InnoDB 引擎在可重复读级别通过间隙锁机制，很大程度上避免了幻读）。
- 串行化（Serializable）：防止所有三种问题，但性能开销较大。

## 不可重复读与幻读的区别

- **幻读**：针对数据的**数量**。在事务期间，由于其他事务提交了新插入或删除的记录，导致同一查询操作返回的结果集总量发生变化（比如多了或少了记录）。
- **不可重复读**：针对数据的**内容**。在事务执行期间，同一条数据的字段值被其他已提交的事务修改，导致两次读取该数据时得到不同的内容。
# 3. MySQL 的存储引擎有哪些？它们之间有什么区别？ 
## InnoDB（MySQL 默认引擎）
1. **事务与并发控制**
   - 支持事务，实现四种标准隔离级别，默认使用可重复读级别
   - 利用 MVCC（多版本并发控制）支持高并发
   - 支持行级锁，通过行锁+间隙锁在可重复读级别下有效防止幻读
   - 支持崩溃后的数据安全恢复

2. **外键与约束**
   - 支持外键约束，但互联网项目通常避免使用（性能考虑）
   - 建议通过业务代码实现数据约束逻辑

3. **并发性能**
   - 采用行级锁定，在多用户同时读写场景下表现优异
   - 适合 OLTP（在线事务处理）场景

4. **索引结构**
   - 主键索引为聚簇索引（数据与索引存储在一起）
   - 辅助索引（非主键索引）仅存储索引值与主键
   - 当辅助索引无法覆盖查询列时，需通过主键回表查询完整数据
## MyISAM
1. **功能特性**
   - 基于 ISAM 引擎发展而来
   - 支持全文检索、数据压缩、空间函数
   - **不支持事务和行级锁**，仅提供表级锁
   - 适用于 OLAP（在线分析处理）场景，尤其是以读取操作为主的场景
2. **索引结构**
   - 同样使用 B+ 树索引
   - 数据与索引分开存储，主键索引与非主键索引结构差异不大
   - 叶子节点不存储完整数据，仅指向数据存储位置
两者最核心的区别在于事务支持、锁机制和索引存储方式，这也决定了它们适用于不同的业务场景。
# 4. MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？
## 聚簇索引
- 索引叶子节点存储的是**完整数据行**，可直接访问全部数据，无需额外查询。
- 每个表**只能有一个聚簇索引**，通常默认与主键绑定（若表中无主键，InnoDB 会自动选择唯一索引或生成隐式主键作为聚簇索引依据）。
- 优势：适合**范围查询和排序操作**，因为数据在物理存储上按索引顺序排列，查询连续数据时效率高。

## 非聚簇索引
- 索引叶子节点存储的是**索引列值和对应数据行的主键**，无法直接获取完整数据，需通过主键到聚簇索引中查询完整记录（即“回表”操作）。
- 一个表**可以有多个非聚簇索引**，也称为非主键索引、辅助索引或二级索引。
- 优势：适用于**快速查找特定列的数据**，通过索引键能快速定位到主键，再通过主键获取完整数据，适合高频查询非主键字段的场景。

### 补充说明
- 聚簇索引的核心是“索引与数据物理存储绑定”，数据按索引顺序排列；非聚簇索引则是“索引与数据分离”，索引仅作为指向数据的指针。
- 在 InnoDB 中，聚簇索引是数据存储的基础，非聚簇索引依赖聚簇索引实现数据访问；而 MyISAM 中所有索引均为非聚簇索引，数据与索引完全独立存储。
# 5. MySQL 中的回表是什么
“回表”是数据库查询中的一个重要概念，具体指：  
当使用**二级索引（非聚簇索引）** 作为查询条件时，由于二级索引的叶子节点仅存储**索引字段的值**和对应的**主键值**，无法直接获取数据行中的其他字段信息。若查询需要获取这些未包含在二级索引中的字段，就必须根据已获取的主键值，到**聚簇索引（主键索引）** 中查找完整的数据行，这个过程即称为“回表”。

### 示例说明
假设表 `user` 有聚簇索引（主键 `id`）和二级索引（`name`）：
- 二级索引 `name` 的叶子节点存储 `(name值, id值)`，如 `("张三", 101)`。
- 当执行查询 `SELECT id, name, age FROM user WHERE name = "张三"` 时：
  1. 先通过二级索引 `name` 找到 `id=101`；
  2. 由于 `age` 未在二级索引中存储，需用 `id=101` 到聚簇索引中查询 `age` 的值，这一步就是“回表”。

### 如何减少回表？
- **覆盖索引**：将查询所需的所有字段都包含在二级索引中（如创建 `(name, age)` 联合索引），使二级索引能直接满足查询需求，避免回表。
# 6. 为什么 MySQL 选择使用 B+ 树作为索引结构
1. **高效的查找性能**：
   - B+树是一种自平衡树，每个叶子节点到根节点的路径长度相同。在插入和删除节点时，会通过分裂和合并操作保持树的平衡，且因存在一定冗余节点，删除时树结构的变化较小，效率更高。
   - 查找、插入、删除等操作的时间复杂度均为 O(log n)，即便在大数据量情况下，也能保证较快的响应时间。

2. **树的高度增长不会过快，减少查询磁盘的 I/O 次数**：
   - 与红黑树不同，B+树作为多叉树，数据量增加时树的高度增长不会过快。其非叶子节点仅保存主键或索引值及页面指针，这使得每一页能容纳更多记录，内存中可存放更多索引，更容易命中缓存，从而减少查询磁盘的 I/O 次数。

3. **范围查询能力强**：
   - B+树特别适合范围查询。由于叶子节点通过链表链接，从根节点定位到叶子节点找到范围的起点后，只需顺序扫描链表就能遍历后续数据，效率极高。
# 7. 详细描述一条 SQL 语句在 MySQL 中的执行过程
1. **权限校验**：
   - 首先通过连接器校验用户的操作权限，确保用户具备执行当前SQL语句的权限。

2. **SQL解析**：
   - 利用分析器对SQL语句进行词法分析，将语句拆分为一个个独立的单词（如关键字、表名、列名等）；
   - 接着进行语法分析，检查语句是否符合SQL语法规则，并根据分析结果构建解析树（也称为抽象语法树）。

3. **执行计划优化**：
   - 优化器根据解析树，结合数据库中的统计信息（如表的大小、索引分布等），对执行方案进行优化；
   - 具体包括选择合适的索引、确定表的连接顺序等，最终生成一个最优的执行计划。

4. **执行并返回结果**：
   - 执行器依据优化后的执行计划，调用数据库引擎层的接口来查询数据；
   - 引擎层执行具体的数据读取操作后，将结果集通过执行器返回给客户端。
# 8. MySQL 中的 MVCC 是什么？ 
## 回答重点
MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种数据库并发控制机制，其核心作用是**允许多个事务同时进行读取和写入操作而无需相互等待**，从而有效提升数据库的并发处理性能。

#### MVCC的核心机制
- **数据快照与版本管理**：数据库会为每个事务创建对应的数据快照。当数据被修改时，MySQL不会直接覆盖原有数据，而是生成该记录的新版本，并为每个版本的记录关联对应的版本号或时间戳。
- **版本链的形成**：同一数据的多个版本会串联形成一条版本链。这使得不同时刻启动的事务能够通过“普通读”的方式，无锁地获取到对应时刻的数据版本，实现了读写操作的非阻塞。
- **版本可见性规则**：写操作会持续创建新的数据版本，但只有当事务提交后，新版本才对其他事务可见；未提交事务的修改不会影响其他事务的读取，其他事务仍可读取历史版本的记录。

通过这种机制，MVCC在保证数据一致性的前提下，极大地提高了数据库的并发处理能力，是许多主流数据库（如MySQL InnoDB）实现高效并发控制的重要基础。
## 扩展知识
### Undo Log（回滚日志）
Undo Log 是 MySQL InnoDB 存储引擎中用于支持事务回滚操作的关键日志机制，其核心功能是**记录数据修改的历史信息**，以便在事务执行失败、需要撤销操作或回滚时，能够将数据恢复到修改之前的状态。

#### Undo Log 与 MVCC 的关联
- MVCC 实现的“多版本”并非真正存储了数据的多个物理副本，而是借助 Undo Log 实现的逻辑多版本。
- 索引上的记录始终只保留最新版本，而 Undo Log 会记录每次写操作（如插入、更新、删除）的反向操作（例如，更新操作的反向是“将新值改回旧值”，插入操作的反向是“删除该记录”）。
- 当需要获取数据的历史版本时，数据库会通过 Undo Log 中的记录执行反向操作，从而“还原”出历史版本的数据，使得从用户视角看，数据仿佛存在多个版本。

简言之，Undo Log 不仅是事务回滚的基础，也是 MVCC 实现多版本可见性的重要支撑，通过记录反向操作，在保证数据最新版本唯一性的同时，实现了历史版本的追溯与恢复。
# 9. MySQL 中有哪些锁类型
### MySQL 中的共享锁（S锁）与排他锁（X锁）
- **共享锁（S锁）**：
  - 事务读取记录时获取，允许多个事务同时持有同一资源的 S 锁，彼此之间**不冲突**。
  - 示例：`SELECT ... LOCK IN SHARE MODE;` 会对查询的记录加 S 锁。
- **排他锁（X锁，又称独占锁）**：
  - 事务修改记录（如插入、更新、删除）时获取，**仅允许一个事务持有**，其他事务需阻塞等待。
  - X 锁与 S 锁、X 锁与 X 锁之间均**冲突**。
  - 示例：`SELECT ... FOR UPDATE;` 会对查询的记录加 X 锁。
### 意向锁（Intention Lock）：
一种表锁，用于表示某个事务对某行数据加锁的意图，分为意向共享锁（IS）和意向排它锁（IX），主要用于行级锁与表级锁的结合。

# 10. select count（*/1/字段）区别
- COUNT(*) 统计符合条件的总行数，包括 NULL 值行；
- COUNT(1) 功能类似 COUNT(*)，执行效率在某些数据库中与 COUNT(*) 相近或稍高，因为其以常数 1 为统计对象，无需关注字段内容；
- COUNT(字段) 统计指定字段中非 NULL 值的行数。

