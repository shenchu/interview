# 目录
1. [HashMap 的原理](#1-hashmap-的原理)
2. [ConcurrentHashMap 的原理](#2-concurrenthashmap-的原理)
3. [什么是 Java 中的动态代理?](#3-什么是-java-中的动态代理)

# 1. HashMap 的原理
HashMap是Java集合框架中的核心类，基于哈希表实现键值对（Key-Value）存储，提供O(1)时间复杂度的快速查找。以下是其原理的重点内容：
- **核心数据结构**：采用“数组 + 链表 + 红黑树”的结构。
    - **数组**：也称为桶，初始长度一般为16（可指定），用于存储链表的头节点或红黑树的根节点。
    - **链表**：当发生哈希冲突时，即不同Key的哈希值计算到同一桶索引时，相同桶内的元素以链表存储。Java 7采用头插法，Java 8改为尾插法。
    - **红黑树**：当链表长度≥8且桶数组长度≥64时，链表转为红黑树，以提高查找效率，查找效率从O(n)提升到O(log n)。当红黑树节点数≤6时，退化为链表。
- **哈希函数设计**：通过扰动算法计算键（Key）的哈希值，以分散分布避免碰撞。
    - 首先调用key.hashCode()获取原始哈希值。
    - 然后将高16位异或低16位，把高位的随机性扩散到低位，解决低位相同导致的冲突。
    - 最后通过index = (table.length - 1) & hash定位桶索引，等价于取模运算，但效率更高。
- **哈希冲突解决方案**：采用链地址法。当不同Key的哈希值计算到同一桶索引时，桶内元素以Node链表连接，若满足条件则转换为红黑树进行优化。
- **动态扩容机制**：当元素数量超过阈值（threshold = capacity * loadFactor）时触发扩容。
    - 新容量 = 旧容量 × 2，保持2的幂，便于位运算计算索引。
    - 迁移元素时，只需判断新增高位比特，无需重新计算哈希。旧索引为i的元素，新索引只能是i或i + oldCap。
    - 默认负载因子为0.75，初始容量为16。
# 2. ConcurrentHashMap 的原理
- **核心特性**：线程安全的哈希表实现，支持高并发读写，替代同步的HashMap（如`Collections.synchronizedMap()`）。

- **JDK 1.7 实现**：
  - **分段锁（Segment）**：将数据分为多个Segment（默认16个），每个Segment独立加锁，实现多线程并发操作不同Segment。
  - **结构**：`Segment[]`数组 + 每个Segment内含`HashEntry[]`数组（链表结构）。
  - **锁粒度**：对Segment加锁，同一时间可多个线程操作不同Segment，并发度为Segment数量。

- **JDK 1.8 实现**：
  - **取消分段锁**：采用「数组 + 链表 + 红黑树」结构（同HashMap），降低锁粒度。
  - **线程安全机制**：
    - **CAS操作**：无锁化处理Node节点的插入/更新（如`putVal`中首次插入节点）。
    - **synchronized锁**：对链表头节点或红黑树的首节点加锁，仅锁定当前操作的桶。
  - **红黑树优化**：同HashMap，链表长度≥8且数组长度≥64时转为红黑树，提升查询效率。

- **扩容机制**：
  - 支持多线程并发扩容，通过`sizeCtl`控制扩容状态，各线程分工迁移桶数据。
  - 迁移时标记桶为`ForwardingNode`，指引其他线程协助扩容或访问新表。

- **弱一致性迭代器**：
  - 迭代时不抛`ConcurrentModificationException`，可能反映部分修改（弱一致性）。
  - 基于`Unsafe`类的volatile读保证可见性，避免全表加锁。

- **与HashMap对比**：
  - 不允许`null`键（JDK 1.8后允许`null`值，但不推荐）。
  - 读写操作通过细粒度同步机制实现线程安全，并发性能优于同步包装的HashMap。
# 3. 什么是 Java 中的动态代理?
- **回答重点**: 
    - Java 中的动态代理是一种在运行时创建代理对象的机制。动态代理允许程序在运行时决定代理对象的行为，而不需要在编译时确定。它通过代理模式为对象提供了一种机制，使得可以在不修改目标对象的情况下对其行为进行增强或调整。
    - 代理可以看作是调用目标的一个包装，通常用来在调用真实的目标之前进行一些逻辑处理，消除一些重复的代码。静态代理指的是我们预先编码好一个代理类，而动态代理指的是运行时生成代理类，
- **动态代理主要用途**: 
    - 简化代码:通过代理模式，可以减少重复代码，尤其是在横切关注点(如日志记录、事务管理、权限控制等)方面。。
    - 增强灵活性:动态代理使得代码更具灵活性和可扩展性，因为代理对象是在运行时生成的，可以动态地改变行为。
    - 实现 AOP:动态代理是实现面向切面编程(AOP,Aspect-Oriented Programming)的基础，可以在方法调用前后插入额外的逻辑。
- **Java 动态代理与 CGLIB 代理**:
    - Java 动态代理:只能对接口进行代理，不支持对类进行代理。·CGLIB 代理:通过字节码技术动态生成目标类的子类来实现代理，支持对类(非接口)进行代理，
# 4.  Java 的 synchronized 是怎么实现的?
### 回答重点
`synchronized` 实现原理依赖于 JVM 的 Monitor（监视器锁） 和 对象头（Object Header）。  

当 `synchronized` 修饰在方法或代码块上时，会对特定的对象或类加锁，从而确保同一时刻只有一个线程能执行加锁的代码块。  

- `synchronized` 修饰方法：会在方法的访问标志中增加一个 `ACC_SYNCHRONIZED` 标志。每当一个线程访问该方法时，JVM 会检查方法的访问标志。如果包含 `ACC_SYNCHRONIZED` 标志，线程必须先获得该方法对应的对象的监视器锁（即对象锁），然后才能执行该方法，从而保证方法的同步性。  
- `synchronized` 修饰代码块：会在代码块的前后插入 `monitorenter` 和 `monitorexit` 字节码指令。可以把 `monitorenter` 理解为加锁，`monitorexit` 理解为解锁。  
### 扩展知识
#### 对象头（Object Header）
在 JVM 中，每个对象的内存布局主要由两部分组成：  
- Mark Word：用于存储对象的运行时数据，包括锁状态、哈希码、GC 分代信息等。  
- Klass Pointer：指向对象的类型元数据，帮助 JVM 确定对象的类型信息。  
Mark Word 是实现 `synchronized` 的关键，因为它会根据锁的状态保存不同的信息，具体包括：  
- 未锁定状态：Mark Word 存储对象的哈希码和 GC 分代信息。  
- 偏向锁状态：Mark Word 保存获取该锁的线程 ID 和一些偏向锁标志位。  
- 轻量级锁状态：Mark Word 存储的是指向栈中锁记录的指针。  
- 重量级锁状态：Mark Word 存储的是指向 Monitor 对象的指针。
# 5. 什么是 Java 的 CAS (Compare-And-Swap)操作?
### 回答重点  
CAS 是一种**硬件级别的原子操作**，它比较内存中的某个值是否为预期值，如果是，则更新为新值，否则不做修改。  
### 工作原理  
- **比较（Compare）**：CAS 会检查内存中的某个值是否与预期值相等。  
- **交换（Swap）**：如果相等，则将内存中的值更新为新值。  
- **失败重试**：如果不相等，说明有其他线程已经修改了该值，CAS 操作失败，一般会利用重试，直到成功 。
### CAS 的优缺点
#### 优点  
- **无锁并发**：CAS 操作不使用锁，因此不会导致线程阻塞，提高了系统的并发性和性能。  
- **原子性**：CAS 操作是原子的，保证了线程安全。  
#### 缺点  
- **ABA 问题**：CAS 操作中，如果一个变量值从 A 变成 B，又变回 A，CAS 无法检测到这种变化，可能导致错误。  
- **自旋开销**：CAS 操作通常通过自旋实现，可能导致 CPU 资源浪费，尤其在高并发情况下。  
- **单变量限制**：CAS 操作仅适用于单个变量的更新，不适用于涉及多个变量的复杂操作。  
### ABA 问题  
* ABA 问题是指当变量值从 A 变为 B 再变回 A 时，CAS 操作无法检测到这种变化。解决 ABA 问题的一种常见方法是引入版本号或时间戳，每次更新变量时同时更新版本号，从而检测到变量的变化。  
* Java 中的 `AtomicStampedReference` 就提供了版本号解决方案，它内部提供了一个 `Pair` 封装了引用和版本号，利用 `volatile` 保证了可见性。
# 6. 说说 AQS 吧?

简单来说 AQS 就是起到了一个抽象、封装的作用，将一些排队、入队、加锁、中断等方法提供出来，便于其他相关 JUC 锁的使用，具体加锁时机、入队时机等都需要实现类自己控制。  

它主要通过维护一个**共享状态（state）** 和一个**先进先出（FIFO）** 的等待队列，来管理线程对共享资源的访问。  

`state` 用 `volatile` 修饰，表示当前资源的状态。例如，在独占锁中，`state` 为 `0` 表示未被占用，为 `1` 表示已被占用。  

当线程尝试获取资源失败时，会被加入到 AQS 的等待队列中。这个队列是一个变体的 CLH 队列，采用**双向链表**结构，节点包含线程的引用、等待状态以及前驱和后继节点的指针。  

AQS 常见的实现类有 `ReentrantLock`、`CountDownLatch`、`Semaphore` 等等。  

然后面试官会引申问你具体 `ReentrantLock` 的实现原理是怎样的呢？  

参见这题：[ReentrantLock 原理](ReentrantLock原理)。
# 7. Volatile与 Synchronized 的区别是什么?
### 回答重点  
在 Java 中，`volatile` 和 `synchronized` 是两种用于实现线程安全的关键字，但它们的作用和使用场景有很大的区别。  

### 1) volatile  
- 只适用于**字段变量**。  
- 确保变量的**可见性**。每次读取 `volatile` 变量时，会从主内存读取最新值（而非线程本地缓存）；写入时会立即刷新到主内存。  
- 不保证操作的**原子性**。如 `i++` 这类复合操作，即便用 `volatile` 声明，仍可能有线程安全问题。  
- 性能开销小，**不加锁**，仅保证线程间可见。  

### 2) synchronized  
- 用于**方法或代码块**。  
- 保证**原子性**：通过加锁，确保同一时间只有一个线程执行被保护代码块。  
- 保证**可见性**：加锁时从主存读最新值，放锁时写入主存。  
- 性能开销较大，因涉及锁的获取与释放，可能导致线程阻塞。  

### 特性对比表  
| 特性       | volatile          | synchronized      |  
|------------|-------------------|-------------------|  
| 适用范围   | 单个变量          | 方法或代码块      |  
| 可见性     | 保证              | 保证              |  
| 原子性     | 不保证            | 保证              |  
| 性能开销   | 较小              | 较大              |  
| 典型场景   | 状态标志位        | 复杂操作/多变量保护 |
# 8. 